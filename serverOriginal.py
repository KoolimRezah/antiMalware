from socket import *
import optparse
import sys
import os
import pefile
import hashlib
import ssl
import detector2
import entropyBetter
import upx

curPath = os.path.dirname(os.path.abspath(__file__))

sendSize = 1024

# if len(sys.argv) <= 2:
#    print r"Usage: server.py -f file_name"
#    sys.exit()

def makeSock():
    "Creates a TCP socket and listens on port 10056"
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(('', 10056))
    sock.listen(SOMAXCONN)
    print "Listening"

    client, addr = sock.accept()

    print "accepted"
    return (client, sock)


def getFile(fName, size, client):
    "Recieves the file name, size and the client socket and gets the file from the client"
    print size,
    f = open(fName, "wb")
    while (size > 0):
        data = client.recv(sendSize)
        f.write(data)
        client.sendall("c" * 1024)
        #print f.read()
        size = size - sendSize
        print "\r%3d" % size,  #debugging
    print ""
    return f


def checkIAT(peFile):
    "Recieves a file and checks its IAT(Import Address Table) for suspicious functions"
    pe = pefile.PE(peFile)  #peFile is a path, here we open the file as a PE file.

    pe.parse_data_directories()

    address = []
    moduleNames = []

    for entry in pe.DIRECTORY_ENTRY_IMPORT:  #appending all import modules to a list
        #print entry.dll
        for imp in entry.imports:
            address.append(hex(imp.address))
            moduleNames.append(imp.name)

    compare(moduleNames)

    pe.close()


def compare(moduleNames):
    "Help function for checkIAT"
    suspicious = open(os.path.join(curPath, 'suspiciousFunctions.txt')).readlines()
    for func in suspicious:
        for importName in moduleNames:
            if func.replace('\n', '') == importName:
                print "Suspicious function found: ", func


def checkSections(peFile):
    pe = pefile.PE(peFile)
    result = checkSectionsH(pe)
    pe.close()
    if result:
        return "Probably Not Packed"
    return "Probably Packed"


def checkSectionsH(pe):
    defaultSections = ['.text', '.data', '.rdata', '.bss']  #Unpacked default sections

    sections = []

    for section in pe.sections:
        sections.append(section)

    for section in defaultSections:
        if section in sections:
            return False
    return True


def entropy(path):
    entropy = entropyBetter.getEntropy(path)
    print "Entropy - ", entropy
    if (entropy > 90):
        print "Entropy is over 90, probably packed"
    else:
        print "Entropy is lower than 90, probably not packed"


#def main(fileName):
def main():
    client, sock = makeSock()
    sizeAndTests = client.recv(4096)
    fSize = int(sizeAndTests.split(',')[0])
    client.send('c' * 4096)
    resultHash = client.recv(1024)
    #print resultHash
    client.send('c' * 1024)
    path = os.path.join(curPath, "Recieved File", "file.exe")
    f = getFile(path, fSize, client)
    f.close()
    sock.close()
    client.close()

    f = open(path, "rb")

    recievedHash = hashlib.sha256(f.read()).hexdigest()
    #print recievedHash
    if (recievedHash != resultHash):
        print "File not recieved successfully"
        raise Exception("Bad File")

    #resultIsPacked = checkSections(fName)
    #print resultIsPacked
    f.close()
    entropy(path)

    if upx.isUPX(path):
        print "Packed with UPX"
        print "Unpacking..."
        try:
            upx.unpackUPX(path)
        except Exception, e:
            print "Unpacking error:", e
            return False
        print "Unpacked!"

    resultPacker = detector2.main(path)
    print resultPacker

    checkIAT(path)

    print "finished"
    return True


if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.add_option("-f", "--file", dest="file", help="File to recieve")
    option, argument = parser.parse_args()
    try:
        #main(option.file)
        main()
    except Exception, e:
        print "Faield to execute main:", e
